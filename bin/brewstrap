#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use Data::Dumper;
use FileHandle;
use Term::ANSIColor;

my $DEFAULTS_FILE      = $ENV{'PINST_DEFAULTS'} 
                      || "$ENV{'HOME'}/etc/brews";
my $hostname           = defined $ENV{'HOST'} 
                       ? $ENV{'HOST'}
                       : hostname();
   $hostname          =~ s/\..*//;

my  $BOOTSTRAP_URL     = 'https://raw.github.com/gist/323731/39fc1416e34b9f6db201b4a026181f4ceb7cfa74';
my  $BOOTSTRAP_CMD     = qq(ruby -e "$(curl -fsSL ${BOOTSTRAP_URL})");

my $BREW               = '/usr/local/bin/brew';
my $INSTALL_CMD        = "${BREW} install";
my $INSTALLED_CMD      = "${BREW} list";

unless ( -e $BREW ) {
    print colored "cpanm is required for us to install withâ€¦\n", "bold yellow";
    print colored "About to install cpanm:\n", "bold yellow";
    system( $BOOTSTRAP_CMD );
}

my @installed_modules  = get_installed_modules();
my( $default_modules_hash,
    @default_modules ) = get_default_modules();
my  @desired_modules   = get_desired_modules( @default_modules );
my  @needed_modules    = get_needed_modules( @desired_modules );
print Dumper(@needed_modules);
if( @needed_modules ) {
    install_modules( @needed_modules );
}
else {
    print 'hi there';
}

sub get_installed_modules {
    return split( /\s+/, `$INSTALLED_CMD` );
}

sub get_desired_modules {
    my @desired_modules = @ARGV;
    my @default_modules = @_;
    
    if ( -1 == $#desired_modules ) {
        @desired_modules = @default_modules;
    }
    
    return @desired_modules;
}

sub is_installed {
    my $module = shift;
    
    return ( $module ~~ @installed_modules );
}

sub get_needed_modules {
    my @desired_modules = @_;
    my @needed_modules;
    
    
    foreach my $desired_module ( @desired_modules ) {
        
        push( @needed_modules, $desired_module ) if not is_installed( $desired_module );
    }
    
    return @needed_modules;
}

sub install_modules {
    my @needed_modules = @_;
    my $command        = join( ' ', $INSTALL_CMD, @needed_modules );
    
    # print "${command}\n";
    system( $command );
}

sub get_default_modules {
    my $handle = FileHandle->new( $DEFAULTS_FILE )
                 or die "${DEFAULTS_FILE}: $!";
    
    my $assignment_regexp = qr{
        ^
            \s*
            ( [A-Z0-9_]+ )  # key
            \s* = \s*
            (.*)?           # value
            \s*
        $
    }x;
    my $module_regexp = qr{
        ^
            ( [^\s]+ )      # applicable hosts
            \s+
            ( [^\s]+ )      # module
            (?:
                \s* (.*)?   # optional variants
            )?
            \s*
        $
    }x;
    my %assignments;
    my %modules;
    my @order;
    
    LINE:
    while ( my $line = <$handle> ) {
        # remove comments and skip blank linkes
        $line =~ s{ [#] .* $ }{}x;
        next LINE if $line =~ m{ ^ \s* $ }x;
        
        if ( $line =~ $assignment_regexp ) {
            $assignments{$1} = $2;
        }
        elsif ( $line =~ $module_regexp ) {
            my $hosts    = $1;
            my $module     = $2;
            my $variants = $3 || q();
            
            # replace assignments
            foreach my $key ( keys %assignments ) {
                my $value = $assignments{$key};
                $hosts =~ s{$key}{$value};
            }
            
            foreach my $host ( split /,\s*/, $hosts ) {
                if ( $hostname eq $host  or  q(*) eq $host ) {
                    push @order, $module;
                    $modules{$module}{'install'} = 1;

                    foreach my $var ( split /\s+/, $variants ) {
                        $modules{$module}{'variants'}{$var} = 1;
                    }
                }
            }
        }
        else {
            die "File format error:\n$line";
        }
    }
    
    return \%modules, @order;
}
